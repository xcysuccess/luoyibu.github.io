<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[luoyibu' blog]]></title>
  <subtitle><![CDATA[不疯魔不成活]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://luoyibu.com/"/>
  <updated>2015-12-12T08:49:42.000Z</updated>
  <id>http://luoyibu.com/</id>
  
  <author>
    <name><![CDATA[luoyibu]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[关于Core Animation动画（上）]]></title>
    <link href="http://luoyibu.com/2015/11/01/%E5%85%B3%E4%BA%8ECore%20Animation%E5%8A%A8%E7%94%BB%EF%BC%88%E4%B8%8A%EF%BC%89/"/>
    <id>http://luoyibu.com/2015/11/01/关于Core Animation动画（上）/</id>
    <published>2015-11-01T07:54:54.000Z</published>
    <updated>2015-12-12T08:49:42.000Z</updated>
    <content type="html"><![CDATA[<!-- toc -->
<h2 id="UIView_u4E0ECALayer"><a href="#UIView_u4E0ECALayer" class="headerlink" title="UIView与CALayer"></a>UIView与CALayer</h2><p>对于<code>UIView</code>和<code>CALayer</code>，大家应该都很熟悉。通常我们了解到UIView是通过视图树的结构来组织起来的，实际上，UIView管理并维护了另一个图层树(即CALayer树)，真正的在屏幕上显示与动画的实际上是CALayer对象。</p>
<p><strong>如果说CALayer是View的内部实现细节，那么为什么苹果要再封装一层UIView呢，UIView与CALayer的区别又是什么呢？</strong>  </p>
<a id="more"></a>
<p>UIView与CALayer最大的区别就是UIView可以处理用户的交互（如点击事件），而CALayer是不清楚具体的响应者链的，其不能够响应事件。</p>
<p>将响应事件抽象到UIView中的原因，是为了与Mac OS公用一套底层代码(即layer层)。在Mac OS中有一个NSView的类，会用来处理一些与iOS不同的用户事件(比如键盘鼠标)。</p>
<p><strong>对于大部分的简单场景，UIView都可以满足我们的要求。那么研究CALayer有什么用呢？</strong>  </p>
<p>前面我们了解CALayer是无法像UIView那样处理触摸事件的，UIView也有一些没有暴露出来的CALayer的功能：</p>
<ul>
<li>阴影，圆角，边框</li>
<li>3D变换（UIView只有2D变换）</li>
<li>透明遮罩</li>
<li>非矩形范围</li>
<li>非线性动画</li>
<li>其他很多功能，</li>
</ul>
<p><strong>实际上，每个UIView都有一个CALayer实例的图层属性，我们可以通过view.layer来获取。</strong></p>
<p>CALayer有很多特殊的子类，可以实现很多不同的效果，大概可以看看CALayer具体有哪些子类。我们既可以改变UIView的CALayer类别，也可以为其添加不同的CALayer实例。这里暂时不讲太多，本章主要还是以动画为主。</p>
<h2 id="u9690_u5F0F_u52A8_u753B"><a href="#u9690_u5F0F_u52A8_u753B" class="headerlink" title="隐式动画"></a>隐式动画</h2><p>了解CALayer与UIView，我们可以来看看隐式动画，了解什么情况下，系统会自动产生动画。什么情况下，需要我们自己添加动画。</p>
<p>隐式动画实际上是由事物来产生的，我们先看看事物的概念：</p>
<h3 id="u4E8B_u52A1"><a href="#u4E8B_u52A1" class="headerlink" title="事务"></a>事务</h3><p>事务实际上是<code>Core Animation</code>用来包含一系列属性动画集合的机制，任何对CALayer的属性改变都不会立刻发生变化，而是在事务提交后，用一个动画过度到新值。  </p>
<p>Core Animation在每个run loop周期中自动开始一次新的事务，任何在一次run loop循环中<strong>属性</strong>的改变都会集中起来，然后做一次0.25秒的动画。  </p>
<p>比如说，我们添加一个新的layer到视图上，改变其backGroundColor，会发现颜色不是瞬间就改变的，而是经过了0.25s（动画的默认时长）的时间渐变过来。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//CALayer的隐式动画</span></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//创建一个红色的layer</span></span><br><span class="line">    _layer = [<span class="built_in">CALayer</span> layer];</span><br><span class="line">    _layer<span class="variable">.frame</span> = <span class="keyword">self</span><span class="variable">.view</span><span class="variable">.bounds</span>;</span><br><span class="line">    _layer<span class="variable">.backgroundColor</span> = [<span class="built_in">UIColor</span> redColor]<span class="variable">.CGColor</span>;</span><br><span class="line">    [<span class="keyword">self</span><span class="variable">.view</span><span class="variable">.layer</span> addSublayer:_layer];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">IBAction</span>)changeColor:(<span class="keyword">id</span>)sender &#123;</span><br><span class="line">    <span class="comment">//修改layer的颜色为黄色   此时，颜色是由红色渐变到黄色的</span></span><br><span class="line">    _layer<span class="variable">.backgroundColor</span> = [<span class="built_in">UIColor</span> yellowColor]<span class="variable">.CGColor</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>上面就是隐式动画产生的原因，每个run loop中的会默认开启一个事务来完成CALayer的隐私动画。  需要注意的是，UIView所关联的layer，是禁用了隐式动画的。这个时候我们需要自己来实现动画：</strong></p>
<p>我们可以通过CATransaction的<code>+begin</code>和<code>+commit</code>来入栈或者出栈一个新的事务（也可以使用UIView的一些快捷方法，如<code>+beginAnimations:context:</code>和<code>+animateWithDuration:animations:</code>，他们本质上是一样的），在新建的事务中，我们可以修改一些动画相关的设定，比如说duration动画时间，而这些设定是只对当前事务有效的，不会影响到默认run loop中的事务。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对View做动画，需要包含在事物中</span></span><br><span class="line">[<span class="built_in">CATransaction</span> begin];</span><br><span class="line"><span class="keyword">self</span><span class="variable">.view</span><span class="variable">.backgroundColor</span> = [<span class="built_in">UIColor</span> yellowColor];     <span class="comment">//改变view颜色</span></span><br><span class="line">[<span class="built_in">CATransaction</span> setAnimationDuration:<span class="number">1</span>];             <span class="comment">//修改本次事务的动画时间</span></span><br><span class="line">[<span class="built_in">CATransaction</span> setCompletionBlock:^&#123;	               <span class="comment">//动画结束后回调</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"animation completed"</span>);</span><br><span class="line">&#125;];</span><br><span class="line">[<span class="built_in">CATransaction</span> commit];  <span class="comment">//提交动画</span></span><br></pre></td></tr></table></figure>
<h3 id="modelLayer_u4E0EpresentationLayer"><a href="#modelLayer_u4E0EpresentationLayer" class="headerlink" title="modelLayer与presentationLayer"></a>modelLayer与presentationLayer</h3><p>从上面的部分我们知道了CALayer的属性发生变化，会通过一段动画时间来渐变更新,而我们只是设置了backColor的起始值和结束值(由红色变为黄色)。那么是否有办法获取到动画中间状态的backColor呢？</p>
<p>答案是可以的，我们需要了解2个概念，<code>modelLayer</code>与<code>presentationLayer</code>。  </p>
<p>多数情况下，我们创建的一个CALayer实例，是指的modelLayer（可以称为数据图层）。我们对一个layer对象调用-modelLayer通常会返回-self。当一个layer的属性发生变化时，modelLayer的属性值立刻（动画开始前）就发生了变化，在上面的例子中，modelLayer的值是立刻从红色变为黄色的。</p>
<p>而presentationLayer称为展现图层，它实际上是modelLayer的一份拷贝，表示了任意时刻屏幕显示的layer的真实值。也即动画过程中layer中间态的属性值，可以通过presentationLayer来获取。<br>需要注意的是只有layer在第一次屏幕上显示时，presentationLayer才会被创建，在这之前-presentationLayer返回的是nil。</p>
<h2 id="u603B_u7ED3_u4E00_u4E0B"><a href="#u603B_u7ED3_u4E00_u4E0B" class="headerlink" title="总结一下"></a>总结一下</h2><ol>
<li>我们了解了CAlayer是UIView的底层实现，UIView可以处理一些用户触摸的事件，而CALayer则提供了更丰富的底层功能。</li>
<li>对于CALayer的属性改变，runloop会有一个默认的事物来进行隐式动画，而UIView则禁用掉了隐私动画，我们可以通过提交一个新的事物来对UIView的属性改变赋予一个可以控制的动画效果。</li>
<li>我们了解了modelLayer的属性是在修改后立刻就变为终值的，而presentationLayer则会经历一个渐变的修改过程，这对于一些交互性的动画很有帮助。</li>
</ol>
<p><em>后续可能会讲一些Core Animation其他的东西，比如说显示动画，渲染树之类</em></p>
<p>转载请注明出处，我的博客: <a href="luoyibu.com">luoyibu</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<!-- toc -->
<h2 id="UIView_u4E0ECALayer"><a href="#UIView_u4E0ECALayer" class="headerlink" title="UIView与CALayer"></a>UIView与CALayer</h2><p>对于<code>UIView</code>和<code>CALayer</code>，大家应该都很熟悉。通常我们了解到UIView是通过视图树的结构来组织起来的，实际上，UIView管理并维护了另一个图层树(即CALayer树)，真正的在屏幕上显示与动画的实际上是CALayer对象。</p>
<p><strong>如果说CALayer是View的内部实现细节，那么为什么苹果要再封装一层UIView呢，UIView与CALayer的区别又是什么呢？</strong>  </p>]]>
    
    </summary>
    
      <category term="Core Animation" scheme="http://luoyibu.com/tags/Core-Animation/"/>
    
      <category term="iOS" scheme="http://luoyibu.com/tags/iOS/"/>
    
      <category term="动画" scheme="http://luoyibu.com/tags/%E5%8A%A8%E7%94%BB/"/>
    
      <category term="iOS" scheme="http://luoyibu.com/categories/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[iOS异步图片加载优化与常用开源库分析]]></title>
    <link href="http://luoyibu.com/2015/05/12/iOS%E5%BC%82%E6%AD%A5%E5%9B%BE%E7%89%87%E5%8A%A0%E8%BD%BD%E4%BC%98%E5%8C%96%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%BC%80%E6%BA%90%E5%BA%93%E5%88%86%E6%9E%90/"/>
    <id>http://luoyibu.com/2015/05/12/iOS异步图片加载优化与常用开源库分析/</id>
    <published>2015-05-12T14:31:00.000Z</published>
    <updated>2015-12-12T08:40:05.000Z</updated>
    <content type="html"><![CDATA[<!-- toc -->
<p>本篇文章主要讲了一些图片加载优化的过程与思路，同时介绍了一下iOS现有的一些图片加载库的实现思路，并做了一个简单的对比。首先我们看看网络图片显示的大体步骤：</p>
<a id="more"></a>
<h1 id="1-__u7F51_u7EDC_u56FE_u7247_u663E_u793A_u5927_u4F53_u6B65_u9AA4_3A"><a href="#1-__u7F51_u7EDC_u56FE_u7247_u663E_u793A_u5927_u4F53_u6B65_u9AA4_3A" class="headerlink" title="1. 网络图片显示大体步骤:"></a>1. 网络图片显示大体步骤:</h1><ol>
<li>下载图片</li>
<li>图片处理（裁剪，边框等)</li>
<li>写入磁盘</li>
<li>从磁盘读取数据到内核缓冲区</li>
<li>从内核缓冲区复制到用户空间(内存级别拷贝)</li>
<li>解压缩为位图（耗cpu较高）</li>
<li>如果位图数据不是字节对齐的，<code>CoreAnimation</code>会<code>copy</code>一份位图数据并进行字节对齐</li>
<li><code>CoreAnimation</code>渲染解压缩过的位图</li>
</ol>
<blockquote>
<p>以上4，5，6，7，8步是在<code>UIImageView</code>的<code>setImage</code>时进行的，所以默认在主线程进行(iOS UI操作必须在主线程执行)。</p>
</blockquote>
<h1 id="2-__u4E00_u4E9B_u4F18_u5316_u601D_u8DEF_uFF1A"><a href="#2-__u4E00_u4E9B_u4F18_u5316_u601D_u8DEF_uFF1A" class="headerlink" title="2. 一些优化思路："></a>2. 一些优化思路：</h1><ul>
<li>异步下载图片</li>
<li>image解压缩放到子线程</li>
<li>使用缓存 (包括内存级别和磁盘级别)</li>
<li>存储解压缩后的图片，避免下次从磁盘加载的时候再次解压缩</li>
<li>减少内存级别的拷贝 （针对第5点和第7点）</li>
<li>良好的接口（比如<code>SDWebImage</code>使用<code>category</code>）</li>
<li><code>Core Data</code> vs  <a href="http://biasedbit.com/filesystem-vs-coredata-image-cache/" target="_blank" rel="external">文件存储</a></li>
<li>图片预下载</li>
</ul>
<h2 id="2-1__u5173_u4E8E_u5F02_u6B65_u56FE_u7247_u4E0B_u8F7D_3A"><a href="#2-1__u5173_u4E8E_u5F02_u6B65_u56FE_u7247_u4E0B_u8F7D_3A" class="headerlink" title="2.1 关于异步图片下载:"></a>2.1 关于异步图片下载:</h2><p><code>fastImageCache</code>主要针对于从磁盘文件读取并展示图片的极端优化，所以并没有集成异步图片下载的功能。这里主要来看看SDWebImage(AFNetWorking的基本类似)的实现方案：</p>
<h3 id="tableView_u4E2D_uFF0C_u5F02_u6B65_u56FE_u7247_u4E0B_u8F7D_u4EFB_u52A1_u7684_u7BA1_u7406_3A"><a href="#tableView_u4E2D_uFF0C_u5F02_u6B65_u56FE_u7247_u4E0B_u8F7D_u4EFB_u52A1_u7684_u7BA1_u7406_3A" class="headerlink" title="tableView中，异步图片下载任务的管理:"></a>tableView中，异步图片下载任务的管理:</h3><p>我们知道，tableViewCell是有重用机制的，也就是说，内存中只有当前可见的cell数目的实例，滑动的时候，新显示cell会重用被滑出的cell对象。这样就存在一个问题：</p>
<p>一般情况下在我们会在cellForRow方法里面设置cell的图片数据源，也就是说如果一个cell的imageview对象开启了一个下载任务，这个时候该cell对象发生了重用，新的image数据源会开启另外的一个下载任务，由于他们关联的imageview对象实际上是同一个cell实例的imageview对象，就会发生2个下载任务回调给同一个imageview对象。这个时候就有必要做一些处理，避免回调发生时，错误的image数据源刷新了UI。</p>
<p><strong>SDWebImage提供的UIImageView扩展的解决方案：</strong>  </p>
<p>imageView对象会关联一个下载列表（列表是给AnimationImages用的，这个时候会下载多张图片），当tableview滑动，imageView重设数据源（url）时，会cancel掉下载列表中所有的任务，然后开启一个新的下载任务。这样子就保证了只有当前可见的cell对象的imageView对象关联的下载任务能够回调，不会发生image错乱。 </p>
<p>同时，SDWebImage管理了一个全局下载队列（在DownloadManager中）,并发量设置为6.也就是说如果可见cell的数目是大于6的，就会有部分下载队列处于等待状态。而且，在添加下载任务到全局的下载队列中去的时候，SDWebImage默认是采取<code>LIFO</code>策略的，具体是在添加下载任务的时候，将上次添加的下载任务添加依赖为新添加的下载任务。</p>
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">[<span class="keyword">wself.downloadQueue</span> addOperation:operation]<span class="comment">;</span></span><br><span class="line">if <span class="list">(<span class="keyword">wself.executionOrder</span> == SDWebImageDownloaderLIFOExecutionOrder)</span> &#123;</span><br><span class="line">    // Emulate LIFO execution order by systematically adding new operations as last operation<span class="variable">'s</span> dependency</span><br><span class="line">    <span class="list">[<span class="keyword">wself.lastAddedOperation</span> addDependency:operation]<span class="comment">;</span></span><br><span class="line">    wself.lastAddedOperation = operation<span class="comment">;</span></span><br><span class="line">&#125;</span></span></span><br></pre></td></tr></table></figure>
<!--所以在运行SDWebImage的demo的时候，可以看到，如果快速滑下去，然后又滑回来的话，图片是过了一会才显示出来，这是因为快速滑动的时候，旧数据源的下载任务被取消掉了。  -->
<p><strong>另外一种解决方案是：</strong>  </p>
<p>imageView对象和图片的url相关联，在滑动时，不取消旧的下载任务，而是在下载任务完成回调时，进行url匹配，只有匹配成功的image会刷新imageView对象，而其他的image则只做缓存操作，而不刷新UI。  </p>
<p>同时，仍然管理一个执行队列，为了避免占用太多的资源，通常会对执行队列设置一个最大的并发量。此外，为了保证<code>LIFO</code>的下载策略，可以自己维持一个等待队列，每次下载任务开始的时候，将后进入的下载任务插入到等待队列的前面。</p>
<h3 id="iOS_u5F02_u6B65_u4EFB_u52A1_u4E00_u822C_u67093_u79CD_u5B9E_u73B0_u65B9_u5F0F_3A"><a href="#iOS_u5F02_u6B65_u4EFB_u52A1_u4E00_u822C_u67093_u79CD_u5B9E_u73B0_u65B9_u5F0F_3A" class="headerlink" title="iOS异步任务一般有3种实现方式:"></a>iOS异步任务一般有3种实现方式:</h3><ul>
<li>NSOperationQueue</li>
<li>GCD</li>
<li>NSThread</li>
</ul>
<p>这几种方式就不细说了，SDWebImage是通过自定义NSOperation来抽象下载任务的，并结合了GCD来做一些主线程与子线程的切换。具体异步下载的实现，AFNetworking与SDWebImage都是十分优秀的代码，有兴趣的可以深入看看源码。</p>
<h2 id="2-2__u5173_u4E8E_u56FE_u7247_u89E3_u538B_u7F29_3A"><a href="#2-2__u5173_u4E8E_u56FE_u7247_u89E3_u538B_u7F29_3A" class="headerlink" title="2.2 关于图片解压缩:"></a>2.2 关于图片解压缩:</h2><!--### 图片来源
针对app自带的图片，xcode在编译的时候会对png图片进行[优化](http://outofmemory.cn/wr/?u=http%3A%2F%2Fartori.us%2Foptimized-png-in-xcode%2F)（据说是通过[pngcrush](http://pmt.sourceforge.net/pngcrush/)这个开源的工具来优化），这样在显示的时候就会有一些比较好的体验。  
对于从internet上面下载的图片，多数情况下，是需要做解压缩后，才能渲染到屏幕上的。  
-->
<h3 id="u901A_u7528_u7684_u89E3_u538B_u7F29_u65B9_u6848"><a href="#u901A_u7528_u7684_u89E3_u538B_u7F29_u65B9_u6848" class="headerlink" title="通用的解压缩方案"></a>通用的解压缩方案</h3><blockquote>
<p>主体的思路是在子线程，将原始的图片渲染成一张的新的可以字节显示的图片，来获取一个解压缩过的图片。  </p>
</blockquote>
<p>基本上比较流行的一些开源库都先后支持了在异步线程完成图片的解压缩，并对解压缩过后的图片进行缓存。  </p>
<p>这么做的优点是在<code>setImage</code>的时候系统省去了上面的第6步，缺点就是图片占用的空间变大。<br>比如1张50*50像素的图片，在<code>retina</code>的屏幕下所占用的空间为100*100*4 ~ 40KB</p>
<p>下面的代码是<code>SDWebImage</code>的解决方案:</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="built_in">UIImage</span> *)decodedImageWithImage:(<span class="built_in">UIImage</span> *)image &#123;</span><br><span class="line">    <span class="keyword">if</span> (image<span class="variable">.images</span>) &#123;</span><br><span class="line">        <span class="comment">// Do not decode animated images</span></span><br><span class="line">        <span class="keyword">return</span> image;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">CGImageRef</span> imageRef = image<span class="variable">.CGImage</span>;</span><br><span class="line">    <span class="built_in">CGSize</span> imageSize = <span class="built_in">CGSizeMake</span>(<span class="built_in">CGImageGetWidth</span>(imageRef), <span class="built_in">CGImageGetHeight</span>(imageRef));</span><br><span class="line">    <span class="built_in">CGRect</span> imageRect = (<span class="built_in">CGRect</span>)&#123;<span class="variable">.origin</span> = <span class="built_in">CGPointZero</span>, <span class="variable">.size</span> = imageSize&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">CGColorSpaceRef</span> colorSpace = <span class="built_in">CGColorSpaceCreateDeviceRGB</span>();</span><br><span class="line">    <span class="built_in">CGBitmapInfo</span> bitmapInfo = <span class="built_in">CGImageGetBitmapInfo</span>(imageRef);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> infoMask = (bitmapInfo &amp; k<span class="built_in">CGBitmapAlphaInfoMask</span>);</span><br><span class="line">    <span class="built_in">BOOL</span> anyNonAlpha = (infoMask == k<span class="built_in">CGImageAlphaNone</span> ||</span><br><span class="line">            infoMask == k<span class="built_in">CGImageAlphaNoneSkipFirst</span> ||</span><br><span class="line">            infoMask == k<span class="built_in">CGImageAlphaNoneSkipLast</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// CGBitmapContextCreate doesn't support kCGImageAlphaNone with RGB.</span></span><br><span class="line">    <span class="comment">// https://developer.apple.com/library/mac/#qa/qa1037/_index.html</span></span><br><span class="line">    <span class="keyword">if</span> (infoMask == k<span class="built_in">CGImageAlphaNone</span> &amp;&amp; <span class="built_in">CGColorSpaceGetNumberOfComponents</span>(colorSpace) &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// Unset the old alpha info.</span></span><br><span class="line">        bitmapInfo &amp;= ~k<span class="built_in">CGBitmapAlphaInfoMask</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Set noneSkipFirst.</span></span><br><span class="line">        bitmapInfo |= k<span class="built_in">CGImageAlphaNoneSkipFirst</span>;</span><br><span class="line">    &#125;</span><br><span class="line">            <span class="comment">// Some PNGs tell us they have alpha but only 3 components. Odd.</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!anyNonAlpha &amp;&amp; <span class="built_in">CGColorSpaceGetNumberOfComponents</span>(colorSpace) == <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="comment">// Unset the old alpha info.</span></span><br><span class="line">        bitmapInfo &amp;= ~k<span class="built_in">CGBitmapAlphaInfoMask</span>;</span><br><span class="line">        bitmapInfo |= k<span class="built_in">CGImageAlphaPremultipliedFirst</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// It calculates the bytes-per-row based on the bitsPerComponent and width arguments.</span></span><br><span class="line">    <span class="built_in">CGContextRef</span> context = <span class="built_in">CGBitmapContextCreate</span>(<span class="literal">NULL</span>,</span><br><span class="line">            imageSize<span class="variable">.width</span>,</span><br><span class="line">            imageSize<span class="variable">.height</span>,</span><br><span class="line">            <span class="built_in">CGImageGetBitsPerComponent</span>(imageRef),</span><br><span class="line">            <span class="number">0</span>,</span><br><span class="line">            colorSpace,</span><br><span class="line">            bitmapInfo);</span><br><span class="line">    <span class="built_in">CGColorSpaceRelease</span>(colorSpace);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If failed, return undecompressed image</span></span><br><span class="line">    <span class="keyword">if</span> (!context) <span class="keyword">return</span> image;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">CGContextDrawImage</span>(context, imageRect, imageRef);</span><br><span class="line">    <span class="built_in">CGImageRef</span> decompressedImageRef = <span class="built_in">CGBitmapContextCreateImage</span>(context);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">CGContextRelease</span>(context);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">UIImage</span> *decompressedImage = [<span class="built_in">UIImage</span> imageWith<span class="built_in">CGImage</span>:decompressedImageRef scale:image<span class="variable">.scale</span> orientation:image<span class="variable">.imageOrientation</span>];</span><br><span class="line">    <span class="built_in">CGImageRelease</span>(decompressedImageRef);</span><br><span class="line">    <span class="keyword">return</span> decompressedImage;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-3__u5173_u4E8E_u5B57_u8282_u5BF9_u9F50"><a href="#2-3__u5173_u4E8E_u5B57_u8282_u5BF9_u9F50" class="headerlink" title="2.3 关于字节对齐"></a>2.3 关于字节对齐</h2><p>SDWebImage与AFNetworking都没有对第7点做优化，FastImageCache相对与其他的开源库，则对第5点与第7点做了优化。这里我们谈谈第七点，关于图片数据的字节对齐。</p>
<blockquote>
<p>Core Animation在某些情况下渲染前会先拷贝一份图像数据，通常是在图像数据非字节对齐的情况下会进行拷贝处理，官方文档没有对这次拷贝行为作说明，模拟器和Instrument里有高亮显示“copied images”的功能，但似乎它有bug，即使某张图片没有被高亮显示出渲染时被copy，从调用堆栈上也还是能看到调用了CA::Render::copy_image方法：</p>
<p>那什么是字节对齐呢，按我的理解，为了性能，底层渲染图像时不是一个像素一个像素渲染，而是一块一块渲染，数据是一块块地取，就可能遇到这一块连续的内存数据里结尾的数据不是图像的内容，是内存里其他的数据，可能越界读取导致一些奇怪的东西混入，所以在渲染之前CoreAnimation要把数据拷贝一份进行处理，确保每一块都是图像数据，对于不足一块的数据置空。大致图示：(pixel是图像像素数据，data是内存里其他数据)</p>
<p>块的大小应该是跟CPU cache line有关，ARMv7是32byte，A9是64byte，在A9下CoreAnimation应该是按64byte作为一块数据去读取和渲染，让图像数据对齐64byte就可以避免CoreAnimation再拷贝一份数据进行修补。FastImageCache做的字节对齐就是这个事情。</p>
</blockquote>
<p><img src="http://luoyibu.qiniudn.com/VZB3Qn.png" alt=""></p>
<p>从代码上来看，主要是在创建上图解码的过程中，<code>CGBitmapContextCreate</code>函数的<code>bytesPerRow</code>参数必须传<strong>64的倍数</strong>。</p>
<p>比较各个开源框架的代码，可以看到SDWebImage与AFNetworking的该参数都传的是0，即让系统自动来计算该值（那为何系统自动计算的时候不让图片数据字节就字节对齐呢？）。</p>
<h2 id="2-4__u5173_u4E8E_u7B2C3_uFF0C4_u70B9_uFF0C_u5185_u5B58_u7EA7_u522B_u62F7_u8D1D"><a href="#2-4__u5173_u4E8E_u7B2C3_uFF0C4_u70B9_uFF0C_u5185_u5B58_u7EA7_u522B_u62F7_u8D1D" class="headerlink" title="2.4 关于第3，4点，内存级别拷贝"></a>2.4 关于第3，4点，内存级别拷贝</h2><p>以上3个开源库中，FastImageCache对这一点做了很大的优化，其他的2个开源库则未关注这一点。这一块木有深入研究，就引用一下FastImageCache团队对该点的一些说明。有能力的可以去看看原文章(英文):<a href="https://github.com/path/FastImageCache" target="_blank" rel="external">here</a>。</p>
<blockquote>
<p>内存映射<br>平常我们读取磁盘上的一个文件，上层API调用到最后会使用系统方法read()读取数据，内核把磁盘数据读入内核缓冲区，用户再从内核缓冲区读取数据复制到用户内存空间，这里有一次内存拷贝的时间消耗，并且读取后整个文件数据就已经存在于用户内存中，占用了进程的内存空间。</p>
<p>FastImageCache采用了另一种读写文件的方法，就是用<code>mmap</code>把文件映射到用户空间里的虚拟内存，文件中的位置在虚拟内存中有了对应的地址，可以像操作内存一样操作这个文件，相当于已经把整个文件放入内存，但在真正使用到这些数据前却不会消耗物理内存，也不会有读写磁盘的操作，只有真正使用这些数据时，也就是图像准备渲染在屏幕上时，虚拟内存管理系统VMS才根据缺页加载的机制从磁盘加载对应的数据块到物理内存，再进行渲染。这样的文件读写文件方式少了数据从内核缓存到用户空间的拷贝，效率很高。</p>
</blockquote>
<h2 id="2-5__u5173_u4E8E_u7B2C_u4E8C_u6B65_u56FE_u7247_u5904_u7406_uFF08_u88C1_u526A_uFF0C_u8FB9_u6846_u7B49_uFF09"><a href="#2-5__u5173_u4E8E_u7B2C_u4E8C_u6B65_u56FE_u7247_u5904_u7406_uFF08_u88C1_u526A_uFF0C_u8FB9_u6846_u7B49_uFF09" class="headerlink" title="2.5 关于第二步图片处理（裁剪，边框等）"></a>2.5 关于第二步图片处理（裁剪，边框等）</h2><p>一般情况下，对于下载下来的图片我们可能想要做一些处理，比如说做一些缩放，裁剪，或者添加圆角等等。  </p>
<p>对于比较通用的缩放，或者圆角等功能，可以集成到控件本身。不过，提供一个接口出来，让使用者能够有机会对下载下来的图片做一些其他的特殊处理是有必要的。</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/** SDWebImage</span><br><span class="line"> * Allows <span class="keyword">to</span> transform <span class="keyword">the</span> image immediately <span class="keyword">after</span> <span class="keyword">it</span> has been downloaded <span class="keyword">and</span> just <span class="keyword">before</span> <span class="keyword">to</span> cache <span class="keyword">it</span> <span class="function_start"><span class="keyword">on</span></span> disk <span class="keyword">and</span> memory.</span><br><span class="line"> * NOTE: This method <span class="keyword">is</span> called <span class="keyword">from</span> a <span class="keyword">global</span> queue <span class="keyword">in</span> order <span class="keyword">to</span> <span class="keyword">not</span> <span class="keyword">to</span> block <span class="keyword">the</span> main thread.</span><br><span class="line"> *</span><br><span class="line"> * @param imageManager The current `SDWebImageManager`</span><br><span class="line"> * @param image        The image <span class="keyword">to</span> transform</span><br><span class="line"> * @param imageURL     The url <span class="keyword">of</span> <span class="keyword">the</span> image <span class="keyword">to</span> transform</span><br><span class="line"> *</span><br><span class="line"> * @<span class="constant">return</span> The transformed image object.</span><br><span class="line"> */</span><br><span class="line">- (UIImage *)imageManager:(SDWebImageManager *)imageManager transformDownloadedImage:(UIImage *)image withURL:(NSURL *)imageURL;</span><br></pre></td></tr></table></figure>
<h2 id="2-6__u5176_u4ED6_uFF08_u8BF8_u5982_u56FE_u7247_u9884_u4E0B_u8F7D_uFF0Cgif_u652F_u6301_u7B49_u7B49_2C_u4E0B_u8F7D_u8FDB_u5EA6_u6761_uFF09"><a href="#2-6__u5176_u4ED6_uFF08_u8BF8_u5982_u56FE_u7247_u9884_u4E0B_u8F7D_uFF0Cgif_u652F_u6301_u7B49_u7B49_2C_u4E0B_u8F7D_u8FDB_u5EA6_u6761_uFF09" class="headerlink" title="2.6 其他（诸如图片预下载，gif支持等等,下载进度条）"></a>2.6 其他（诸如图片预下载，gif支持等等,下载进度条）</h2><p>待补充</p>
<h1 id="3-__u5E38_u7528_u7684_u5F00_u6E90_u5E93_u5BF9_u6BD4"><a href="#3-__u5E38_u7528_u7684_u5F00_u6E90_u5E93_u5BF9_u6BD4" class="headerlink" title="3. 常用的开源库对比"></a>3. 常用的开源库对比</h1><table>
<thead>
<tr>
<th style="text-align:center">tip</th>
<th style="text-align:center">SDWebImage</th>
<th style="text-align:center">AFNetworking</th>
<th style="text-align:center">FastImageCache </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"> 异步下载图片</td>
<td style="text-align:center">YES</td>
<td style="text-align:center">YES</td>
<td style="text-align:center">NO</td>
</tr>
<tr>
<td style="text-align:center"> 子线程解压缩</td>
<td style="text-align:center">YES</td>
<td style="text-align:center">YES</td>
<td style="text-align:center">YES</td>
</tr>
<tr>
<td style="text-align:center"> 子线程图片处理(缩放，圆角等)</td>
<td style="text-align:center">YES</td>
<td style="text-align:center">YES</td>
<td style="text-align:center">YES</td>
</tr>
<tr>
<td style="text-align:center"> 存储解压缩后的位图</td>
<td style="text-align:center">YES</td>
<td style="text-align:center">YES</td>
<td style="text-align:center">YES</td>
</tr>
<tr>
<td style="text-align:center"> 内存级别缓存</td>
<td style="text-align:center">YES</td>
<td style="text-align:center">YES</td>
<td style="text-align:center">YES</td>
</tr>
<tr>
<td style="text-align:center"> 磁盘级别缓存</td>
<td style="text-align:center">YES</td>
<td style="text-align:center">YES</td>
<td style="text-align:center">YES</td>
</tr>
<tr>
<td style="text-align:center"> UIImageView category</td>
<td style="text-align:center">YES</td>
<td style="text-align:center">NO</td>
<td style="text-align:center">NO</td>
</tr>
<tr>
<td style="text-align:center"> 减少内存级别的拷贝</td>
<td style="text-align:center">NO</td>
<td style="text-align:center">NO</td>
<td style="text-align:center">YES</td>
</tr>
<tr>
<td style="text-align:center"> 接口易用性</td>
<td style="text-align:center"><em>*</em></td>
<td style="text-align:center"><em>*</em></td>
<td style="text-align:center">*</td>
</tr>
</tbody>
</table>
<h4 id="u53C2_u8003_u8D44_u6599"><a href="#u53C2_u8003_u8D44_u6599" class="headerlink" title="参考资料"></a>参考资料</h4><ol>
<li><a href="https://github.com/path/FastImageCache" target="_blank" rel="external">FastImageCache-github</a>  </li>
<li><a href="https://github.com/rs/SDWebImage" target="_blank" rel="external">SDWebImage-github</a></li>
<li><a href="https://github.com/AFNetworking/AFNetworking" target="_blank" rel="external">AFNetworking-github</a> </li>
<li><a href="http://biasedbit.com/filesystem-vs-coredata-image-cache/" target="_blank" rel="external">File System vs Core Data: the image cache test</a>  </li>
<li><a href="https://bpoplauschi.wordpress.com/2014/03/21/ios-image-caching-sdwebimage-vs-fastimage/" target="_blank" rel="external">iOS image caching. Libraries benchmark (SDWebImage vs FastImageCache)</a>  </li>
<li><a href="http://www.cocoanetics.com/2011/10/avoiding-image-decompression-sickness/" target="_blank" rel="external">Avoiding Image Decompression Sickness</a></li>
<li><a href="http://blog.cnbang.net/tech/2578/?utm_source=tuicool" target="_blank" rel="external">iOS图片加载速度极限优化—FastImageCache解析</a></li>
</ol>
<hr>
<p>转载请注明出处哦，我的博客: <a href="http://www.luoyibu.com" target="_blank" rel="external">luoyibu</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<!-- toc -->
<p>本篇文章主要讲了一些图片加载优化的过程与思路，同时介绍了一下iOS现有的一些图片加载库的实现思路，并做了一个简单的对比。首先我们看看网络图片显示的大体步骤：</p>]]>
    
    </summary>
    
      <category term="AFNetworking" scheme="http://luoyibu.com/tags/AFNetworking/"/>
    
      <category term="SDWebimage" scheme="http://luoyibu.com/tags/SDWebimage/"/>
    
      <category term="iOS" scheme="http://luoyibu.com/tags/iOS/"/>
    
      <category term="异步图片加载" scheme="http://luoyibu.com/tags/%E5%BC%82%E6%AD%A5%E5%9B%BE%E7%89%87%E5%8A%A0%E8%BD%BD/"/>
    
      <category term="iOS" scheme="http://luoyibu.com/categories/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[GCD实现单一资源的多读单写]]></title>
    <link href="http://luoyibu.com/2014/10/26/GCD%E5%AE%9E%E7%8E%B0%E5%8D%95%E4%B8%80%E8%B5%84%E6%BA%90%E7%9A%84%E5%A4%9A%E8%AF%BB%E5%8D%95%E5%86%99/"/>
    <id>http://luoyibu.com/2014/10/26/GCD实现单一资源的多读单写/</id>
    <published>2014-10-26T07:25:56.000Z</published>
    <updated>2015-12-12T08:40:09.000Z</updated>
    <content type="html"><![CDATA[<!-- toc -->
<p>在多线程编程中，最常见的场景是如何保证线程安全，比如你可能经常遇到多线程访问某个dic（又或者是array或其他）造成的crash。<br>这篇文章里，我们讨论下如何使用GCD实现多线程读者与写者问题，也即单一资源的线程安全问题。</p>
<a id="more"></a>
<p>首先，还是先将示例代码放出来好了，后面会有一些我遇到过的问题及改进介绍。如果你只想得到一个解决方案，只需要看第一节就OK，当然，也许你也有兴趣看看后面的部分。</p>
<h1 id="u89E3_u51B3_u65B9_u6848_u4E0E_u539F_u7406"><a href="#u89E3_u51B3_u65B9_u6848_u4E0E_u539F_u7406" class="headerlink" title="解决方案与原理"></a>解决方案与原理</h1><p><strong>ARC版本</strong><br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">_ioQueue = dispatch_queue_create(<span class="string">"ioQueue"</span>, <span class="type">DISPATCH_QUEUE_CONCURRENT</span>);</span><br><span class="line">- (<span class="type">void</span>)setSafeObject:(id)<span class="keyword">object</span> forKey:(<span class="type">NSString</span> *)key</span><br><span class="line">&#123;</span><br><span class="line">    key = [key copy];</span><br><span class="line">    dispatch_barrier_async(self.ioQueue, ^&#123;</span><br><span class="line">        <span class="keyword">if</span> (key &amp;&amp; <span class="keyword">object</span>) &#123;</span><br><span class="line">            [_dic setObject:<span class="keyword">object</span> forKey:key];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">- (id)getSafeObjectForKey:(<span class="type">NSString</span> *)key</span><br><span class="line">&#123;</span><br><span class="line">    __block id <span class="literal">result</span> = <span class="keyword">nil</span>;</span><br><span class="line">    dispatch_sync(self.ioQueue, ^&#123;</span><br><span class="line">        <span class="literal">result</span> = [_dic objectForKey:key];</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">result</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>首先，我们需要创建一个私有的队列来处理读写操作。在这里不推荐使用<code>globe_queue</code>, 因为我们通过<code>dispatch_barrier_async</code>来保证写操作的互斥，我们当然不希望写操作阻塞住<code>globe_queue</code>中的其他不相关任务，我们只希望在写的同时，不会有其他的写操作或者读操作。</p>
<pre><code>同时，也不推荐给队列设置优先级，多数情况下使用default就可以了。而改变优先级往往会造成一些无法预料的问题，比如优先级反转(具体的可以参看参考文献)。
</code></pre><p><img src="http://luoyibu-blog.qiniudn.com/dispatch_barrier.png" alt="dispatch_barrier"> <em>图片来自参考文献</em><br><code>dispatch_barrier_async</code>的block运行时机是，在它之前所有的任务执行完毕，并且在它后面的任务开始之前，期间不会有其他的任务执行。注意在barrier执行的时候，队列本质上如同一个串行队列，其执行完以后才会恢复到并行队列。<br><br>另外一个值得注意的问题是，在写操作的时候，我们使用<code>dispatch_async</code>，而在读操作的时候我们使用<code>dispatch_sync</code>。很明显，这2个操作一个是异步的，一个是同步的。我们不需要使每次程序执行的时候都等待写操作完成，所以写操作异步执行，但是我们需要同步的执行读操作来保证程序能够立刻得到它想要的值。<br><br>使用sync的时候需要极其的小心，因为稍不注意，就有可能产生死锁，这可能造成灾难性的后果。你肯定也注意到了在写操作的时候对key进行了copy, 关于此处的解释，插入一段来自参考文献的引用:</p>
<blockquote>
<p>函数调用者可以自由传递一个<code>NSMutableString</code>的key，并且能够在函数返回后修改它。因此我们必须对传入的字符串使用<code>copy</code>操作以确保函数能够正确地工作。如果传入的字符串不是可变的（也就是正常的<code>NSString</code>类型），调用copy基本上是个空操作。</p>
</blockquote>
<p><br><br><em>到这里整个基本示例代码已经完成，一般情况下能够满足我们的需要。下面来看看在MRC过程中我遇到的一些问题。</em></p>
<h1 id="u5173_u4E8E_u6B7B_u9501"><a href="#u5173_u4E8E_u6B7B_u9501" class="headerlink" title="关于死锁"></a>关于死锁</h1><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">dispatch_queue_t queueA<span class="comment">; // 串行队列</span></span><br><span class="line">dispatch_sync<span class="list">(<span class="keyword">queueA</span>, ^<span class="list">()</span>&#123;    </span><br><span class="line">    dispatch_sync<span class="list">(<span class="keyword">queueA</span>, ^<span class="list">()</span>&#123;        </span><br><span class="line">        foo<span class="list">()</span><span class="comment">;    </span></span><br><span class="line">    &#125;)</span><span class="comment">;</span></span><br><span class="line">&#125;)</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>造成死锁比较常见的情况可以简化成上面这段代码。<br><br><code>dispatch_sync</code>会同步的提交工作并在返回前等待其完成。第一个<code>dispatch_sync</code>正在运行并等待它的block完成，但是block不能够完成，它调用了第二个<code>dispatch_sync</code>，而第二个<code>dispatch_sync</code>会等待串行队列中已经存在的第一个任务完成，很明显这个任务无法完成，造成死锁。</p>
<pre><code>值得注意的是main_queue就是一个串行队列。
</code></pre><h1 id="MRC_u4E0B_u5BB9_u6613_u9047_u5230_u7684_u95EE_u9898_u4E0E_u89E3_u51B3_u65B9_u6848"><a href="#MRC_u4E0B_u5BB9_u6613_u9047_u5230_u7684_u95EE_u9898_u4E0E_u89E3_u51B3_u65B9_u6848" class="headerlink" title="MRC下容易遇到的问题与解决方案"></a>MRC下容易遇到的问题与解决方案</h1><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="type">void</span>)setSafeObject:(id)<span class="keyword">object</span> forKey:(<span class="type">NSString</span> *)key</span><br><span class="line">&#123;</span><br><span class="line">    key = [key copy];</span><br><span class="line">    dispatch_barrier_async(self.ioQueue, ^&#123;</span><br><span class="line">        <span class="keyword">if</span> (key &amp;&amp; <span class="keyword">object</span>) &#123;</span><br><span class="line">            [_dic setObject:<span class="keyword">object</span> forKey:key];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    [key release];</span><br><span class="line">&#125;</span><br><span class="line">- (id)getSafeObjectForKey:(<span class="type">NSString</span> *)key</span><br><span class="line">&#123;</span><br><span class="line">    __block id <span class="literal">result</span> = <span class="keyword">nil</span>;</span><br><span class="line">    dispatch_sync(self.ioQueue, ^&#123;</span><br><span class="line">        <span class="literal">result</span> = [_dic objectForKey:key];</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">result</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先我们看看上面这段代码，基本就是ARC版本转换过来的，看起来没问题。那么究竟是不是真的没问题，我们跑段代码试试看：<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//版本一</span><br><span class="line">- (<span class="type">void</span>)test</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000</span>; i++) &#123;				</span><br><span class="line">        dispatch_async(dispatch_get_global_queue(<span class="type">DISPATCH_QUEUE_PRIORITY_DEFAULT</span>, <span class="number">0</span>), ^&#123;</span><br><span class="line">            [self setSafeObject:[<span class="type">NSString</span> stringWithFormat:@<span class="string">"86+131633829%i"</span>, i] forKey:<span class="type">KEY</span>];</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="type">NSString</span> *<span class="literal">result</span> = [self getSafeObjectForKey:<span class="type">KEY</span>];</span><br><span class="line">        <span class="type">NSLog</span>(@<span class="string">"get string: %@, length : %lu"</span>, <span class="literal">result</span>, <span class="literal">result</span>.length);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>test执行后，很快就会发生crash，读操作的result会发生野指针。<br><br>如果你有经验的话，可能会发现问题:<br>如果某个线程a刚取出了result值，这次线程b开始执行写操作，造成线程a中的result值成为了一份过期的数据，如果正好线程b的runloop结束，很有可能旧的result内存地址被释放掉,这时线程a中的result就会发生野指针crash。<br><br><em>这时候，你可能会采取这样子的修改，代码如下: </em><br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//版本二</span><br><span class="line">- (<span class="type">void</span>)test</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000</span>; i++) &#123;				</span><br><span class="line">        dispatch_async(dispatch_get_global_queue(<span class="type">DISPATCH_QUEUE_PRIORITY_DEFAULT</span>, <span class="number">0</span>), ^&#123;</span><br><span class="line">            [self setSafeObject:[<span class="type">NSString</span> stringWithFormat:@<span class="string">"86+131633829%i"</span>, i] forKey:<span class="type">KEY</span>];</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="type">NSString</span> *<span class="literal">result</span> = [[self getSafeObjectForKey:<span class="type">KEY</span>] retain];</span><br><span class="line">        <span class="type">NSLog</span>(@<span class="string">"get string: %@, length : %lu"</span>, <span class="literal">result</span>, <span class="literal">result</span>.length);</span><br><span class="line">        [<span class="literal">result</span> release];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行之后会发现，仍然会crash，其实问题和上面一样，我们的改动没有真正的解决问题。最好的解决方案是在读操作之前就已经<code>retain</code>住了，看看最终版的代码吧:<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//最终版</span><br><span class="line">- (id)getSafeObjectForKey:(<span class="type">NSString</span> *)key</span><br><span class="line">&#123;</span><br><span class="line">    __block id <span class="literal">result</span> = <span class="keyword">nil</span>;</span><br><span class="line">    dispatch_sync(self.ioQueue, ^&#123;</span><br><span class="line">        <span class="literal">result</span> = [[_dic objectForKey:key] retain];</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> [<span class="literal">result</span> autorelease];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<pre><code>注意retain过一定要释放掉，不然或造成内存泄露。
</code></pre><p>再次验证后发现，程序不会crash了，恭喜。<br><br><br><em>GCD是一套很好用的多线程库，更多的用法请看参考资料</em></p>
<h1 id="u53C2_u8003_u8D44_u6599"><a href="#u53C2_u8003_u8D44_u6599" class="headerlink" title="参考资料"></a>参考资料</h1><ol>
<li><a href="http://objccn.io/issue-2-3/" target="_blank" rel="external">底层并发 API</a></li>
<li><a href="http://objccn.io/issue-2-1/#priority_inversion" target="_blank" rel="external">并发编程：API 及挑战</a></li>
<li><a href="https://github.com/nixzhu/dev-blog/blob/master/2014-04-19-grand-central-dispatch-in-depth-part-1.md" target="_blank" rel="external">GCD 深入理解：第一部分</a></li>
<li><a href="https://github.com/nixzhu/dev-blog/blob/master/2014-05-14-grand-central-dispatch-in-depth-part-2.md" target="_blank" rel="external">GCD 深入理解：第二部分</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<!-- toc -->
<p>在多线程编程中，最常见的场景是如何保证线程安全，比如你可能经常遇到多线程访问某个dic（又或者是array或其他）造成的crash。<br>这篇文章里，我们讨论下如何使用GCD实现多线程读者与写者问题，也即单一资源的线程安全问题。</p>]]>
    
    </summary>
    
      <category term="GCD" scheme="http://luoyibu.com/tags/GCD/"/>
    
      <category term="iOS" scheme="http://luoyibu.com/tags/iOS/"/>
    
      <category term="多线程" scheme="http://luoyibu.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="线程安全" scheme="http://luoyibu.com/tags/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/"/>
    
      <category term="iOS" scheme="http://luoyibu.com/categories/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[ARC下需要注意的内存管理]]></title>
    <link href="http://luoyibu.com/2014/10/18/ARC%E4%B8%8B%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    <id>http://luoyibu.com/2014/10/18/ARC下需要注意的内存管理/</id>
    <published>2014-10-18T10:37:28.000Z</published>
    <updated>2015-12-12T08:40:14.000Z</updated>
    <content type="html"><![CDATA[<!-- toc -->
<p>在2011年的WWDC中，苹果提到90%的crash是由于内存管理引起的，ARC（<code>Automatic Reference Counting</code>）就是苹果给出的解决方案。启用ARC后，开发者不需要担心内存管理，编译器会为你处理这一切<em>（注意ARC是编译器特性，而不是iOS运行时特性，更不是其他语言中的垃圾收集器）。</em><br>简单来说，编译器在编译代码时，会自动生成实例的引用计数代码，帮助我们完成之前MRC需要完成的工作，不过据说除此之外，编译器也会执行某些优化。</p>
<a id="more"></a>
<p><strong>ARC虽然能够解决大部分的内存泄露问题，但是仍然有些地方是我们需要注意的。</strong></p>
<h2 id="u5FAA_u73AF_u5F15_u7528"><a href="#u5FAA_u73AF_u5F15_u7528" class="headerlink" title="循环引用"></a>循环引用</h2><blockquote>
<p><code>循环引用简单来说就是两个对象相互强引用了对方</code>，即retain了对方，从而导致谁也释放不了谁的内存泄露问题。比如声明一个delegate时一般用weak而不能用retain或strong，因为你一旦那么做了，很大可能引起循环引用。</p>
</blockquote>
<p>这种简单的循环引用只要在coding的过程中多加注意，一般都可以发现。<br>解决的办法也很简单，一般是将循环链中的一个强引用改为弱引用就可解决。<br>另外一种block引起的循环引用问题，通常是一些对block原理不太熟悉的开发者不太容易发现的问题。</p>
<h2 id="block_u5F15_u8D77_u7684_u5FAA_u73AF_u5F15_u7528"><a href="#block_u5F15_u8D77_u7684_u5FAA_u73AF_u5F15_u7528" class="headerlink" title="block引起的循环引用"></a>block引起的循环引用</h2><p>我们先看看官方文档关于block调用时的解释：<a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/Blocks/Articles/bxVariables.html#//apple_ref/doc/uid/TP40007502-CH6-SW3" target="_blank" rel="external">Object and Block Variables</a></p>
<blockquote>
<p>When a block is copied, it creates strong references to object variables used within the block. If you use a block within the implementation of a method:</p>
<ol>
<li>If you access an instance variable by reference, a strong reference is made to self;</li>
<li>If you access an instance variable by value, a strong reference is made to the variable.</li>
</ol>
</blockquote>
<p>主要有两条规则：<br><code>第一条规则，如果在block中访问了属性，那么block就会retain住self。</code><br><code>第二条规则，如果在block中访问了一个局部变量，那么block就会对该变量有一个强引用，即retain该局部变量。</code></p>
<p>根据这两条规则，我们可以知道发生循环引用的情况：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//规则1</span></span><br><span class="line"><span class="keyword">self</span><span class="variable">.myblock</span> = ^&#123;</span><br><span class="line">    [<span class="keyword">self</span> doSomething];           <span class="comment">// 访问成员方法</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, weakSelf<span class="variable">.str</span>);   <span class="comment">// 访问属性</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//规则2</span></span><br><span class="line">ASIHTTPRequest *request = [ASIHTTPRequest requestWithURL:url];</span><br><span class="line">[request setCompletionBlock:^&#123;</span><br><span class="line">  <span class="built_in">NSString</span>* string = [request responseString];</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<p>对象对block拥有一个强引用，而block内部又对外部对象有一个强引用，形成了闭环，发生内存泄露。</p>
<p><strong>怎么解决这种内存泄露呢？</strong><br>可以用block变量来解决，首先还是看看官方文档怎么说的:<br><a href="https://developer.apple.com/library/ios/releasenotes/ObjectiveC/RN-TransitioningToARC/Introduction/Introduction.html" target="_blank" rel="external">Use Lifetime Qualifiers to Avoid Strong Reference Cycles</a></p>
<blockquote>
<p>In manual reference counting mode, <code>__block id x</code>; has the effect of not retaining x. In ARC mode, <code>__block id x</code>; defaults to retaining x (just like all other values). To get the manual reference counting mode behavior under ARC, you could use <code>__unsafe_unretained __block id x</code>;. As the name <code>__unsafe_unretained</code> implies, however, having a non-retained variable is dangerous (because it can dangle) and is therefore discouraged. Two better options are to either use <code>__weak</code> (if you don’t need to support iOS 4 or OS X v10.6), or set the <code>__block</code> value to nil to break the retain cycle.</p>
</blockquote>
<p>官网提供了几种方案，我们看看第一种，用__block变量：</p>
<p><code>在MRC中，__block id x不会retain住x；但是在ARC中，默认是retain住x的，我们需要</code><br><code>使用__unsafe_unretained __block id x来达到弱引用的效果。</code></p>
<p>那么解决方案就如下所示：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">__block <span class="keyword">id</span> weakSelf = <span class="keyword">self</span>;  <span class="comment">//MRC</span></span><br><span class="line"><span class="comment">//__unsafe_unretained __block id weakSelf = self;   ARC下面用这个</span></span><br><span class="line"><span class="keyword">self</span><span class="variable">.myblock</span> = ^&#123;</span><br><span class="line">    [weakSelf doSomething];  </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, weakSelf<span class="variable">.str</span>);  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<!-- ## performSelector的问题

    [self performSelector:@selector(foo:) withObject:self.property afterDelay:3];
performSelector延时调用的原理是这样的,执行上面这段函数的时候系统会自动将self.property的`retainCount`加1，直到selector执行完毕之后才会将self.property的`retainCount`减1。这样子如果selector一直未执行的话，self就一直不能够被释放掉，就有可能照成内存泄露。比较好的解决方案是将未执行的perform给取消掉:

    [NSObject cancelPreviousPerformRequestsWithTarget:self];
因这种原因产生的泄露因为并不违反任何规则，是Intrument所无法发现的。 -->
<h2 id="NSTimer_u7684_u95EE_u9898"><a href="#NSTimer_u7684_u95EE_u9898" class="headerlink" title="NSTimer的问题"></a>NSTimer的问题</h2><p>我们都知道timer用来在未来的某个时刻执行一次或者多次我们指定的方法，那么问题来了（当然不是挖掘机）。究竟系统是怎么保证timer触发action的时候，我们指定的方法是有效的呢？万一receiver无效了呢？</p>
<pre><code>答案很简单，系统会自动retain住其接收者，直到其执行我们指定的方法。
</code></pre><p>看看官方的文档吧，也建议你自己写个demo测试一下。<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="tag">NSTimer</span> *)<span class="tag">scheduledTimerWithTimeInterval</span><span class="pseudo">:(NSTimeInterval)seconds</span> <span class="tag">target</span><span class="pseudo">:(id)target</span> <span class="tag">selector</span><span class="pseudo">:(SEL)aSelector</span> <span class="tag">userInfo</span><span class="pseudo">:(id)userInfo</span> <span class="tag">repeats</span><span class="pseudo">:(BOOL)repeats</span></span><br></pre></td></tr></table></figure></p>
<pre><code>target  
The object to which to send the message specified by aSelector when the timer fires. The timer maintains a strong reference to target until it (the timer) is invalidated. (系统会维护一个强引用直到timer调用invalidated)

userInfo  
The user info for the timer. The timer maintains a strong reference to this object until it (the timer) is invalidated. This parameter may be nil.

repeats 
If YES, the timer will repeatedly reschedule itself until invalidated. If NO, the timer will be invalidated after it fires.
</code></pre><p>可以注意到<code>repeats</code>参数，一次性（repeats为NO）的timer会再触发后自动调用invalidated，而重复性的timer则不会。<br><br>现在问题又来了，看看下面这段代码:<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">-</span> (void)<span class="tag">dealloc</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr_selector">[timer invalidate]</span>;</span><br><span class="line">    <span class="attr_selector">[super dealloc]</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个是很容易犯的错误，如果这个timer是个重复性的timer，那么<code>self</code>对象就会被timer<code>retain</code>住，这个时候不调用<code>invalidate</code>的话，<code>self</code>对象的引用计数会大于1，<code>dealloc</code>永远不会调用到，这样内存泄露就会发生。</p>
<pre><code>timer都会对它的target进行retain，我们需要小心对待这个target的生命周期问题，尤其是重复性的timer，同时需要注意在dealloc之前调用invalidate。
</code></pre><p><em>关于timer其实有挺多可以研究的，比如其必须在runloop中才有效，比如其时间一定是准的吗？这些由于和本章主题不相关，暂时就不说了。</em></p>
<h2 id="u5173_u4E8EperformSelector_3AafterDelay_u7684_u95EE_u9898"><a href="#u5173_u4E8EperformSelector_3AafterDelay_u7684_u95EE_u9898" class="headerlink" title="关于performSelector:afterDelay的问题"></a>关于performSelector:afterDelay的问题</h2><pre><code>- (void)performSelector:(SEL)aSelector withObject:(id)anArgument afterDelay:(NSTimeInterval)delay
</code></pre><p>我们还是看看官方文档怎么说的，同样也希望大家能写个demo验证下。</p>
<pre><code>This method sets up a timer to perform the aSelector message on the current thread’s run loop. The timer is configured to run in the default mode (NSDefaultRunLoopMode). When the timer fires, the thread attempts to dequeue the message from the run loop and perform the selector. It succeeds if the run loop is running and in the default mode; otherwise, the timer waits until the run loop is in the default mode.
</code></pre><p>大概意思是系统依靠一个timer来保证延时触发，但是只有在<code>runloop</code>在<code>default mode</code>的时候才会执行成功，否则<code>selector</code>会一直等待<code>run loop</code>切换到<code>default mode</code>。<br><br>根据我们之前关于<code>timer</code>的说法，在这里其实调用performSelector:afterDelay:同样会造成系统对<code>target</code>强引用，也即<code>retain</code>住。这样子，如果<code>selector</code>一直无法执行的话（比如<code>runloop</code>不是运行在<code>default model</code>下）,这样子同样会造成<code>target</code>一直无法被释放掉，发生内存泄露。<br><br>怎么解决这个问题呢？<br>其实很简单，我们在适当的时候取消掉该调用就行了，系统提供了接口:</p>
<pre><code>+ (void)cancelPreviousPerformRequestsWithTarget:(id)aTarget
</code></pre><p><em>这个函数可以在<code>dealloc</code>中调用吗，大家可以自己思考下？</em><br><br><br><br><strong>关于NSNotification的addObserver与removeObserver问题</strong><br>我们应该会注意到我们常常会再<code>dealloc</code>里面调用<code>removeObserver</code>,会不会上面的问题呢？<br><br>答案是否定的，这是因为<code>addObserver</code>只会建立一个弱引用到接收者，所以不会发生内存泄露的问题。但是我们需要在<code>dealloc</code>里面调用<code>removeObserver</code>，避免通知的时候，对象已经被销毁，这时候会发生<code>crash</code>.</p>
<h2 id="C__u8BED_u8A00_u7684_u63A5_u53E3"><a href="#C__u8BED_u8A00_u7684_u63A5_u53E3" class="headerlink" title="C 语言的接口"></a>C 语言的接口</h2><p>C 语言不能够调用OC中的retain与release，一般的C 语言接口都提供了release函数（比如CGContextRelease(context c)）来管理内存。<code>ARC不会自动调用这些C接口的函数，所以这还是需要我们自己来进行管理的.</code></p>
<p>下面是一段常见的绘制代码，其中就需要自己调用release接口。<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CGContextRef</span> context = <span class="built_in">CGBitmapContextCreate</span>(<span class="literal">NULL</span>, target_w, target_h, <span class="number">8</span>, <span class="number">0</span>, rgb, bmi);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">CGColorSpaceRelease</span>(rgb);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">UIImage</span> *pdfImage = <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">if</span> (context != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">CGContextDrawPDFPage</span>(context, page);</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">CGImageRef</span> imageRef = <span class="built_in">CGBitmapContextCreateImage</span>(context);</span><br><span class="line">        <span class="built_in">CGContextRelease</span>(context);</span><br><span class="line"> </span><br><span class="line">        pdfImage = [<span class="built_in">UIImage</span> imageWith<span class="built_in">CGImage</span>:imageRef scale:screenScale orientation:<span class="built_in">UIImageOrientationUp</span>];</span><br><span class="line">        <span class="built_in">CGImageRelease</span>(imageRef);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       <span class="built_in">CGContextRelease</span>(context);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p><br></p>
<p><strong>总的来说，ARC还是很好用的，能够帮助你解决大部分的内存泄露问题。所以还是推荐大家直接使用ARC，尽量不要使用mrc。</strong></p>
<h2 id="u53C2_u8003_u6587_u732E"><a href="#u53C2_u8003_u6587_u732E" class="headerlink" title="参考文献"></a>参考文献</h2><ol>
<li><a href="https://developer.apple.com/library/mac/releasenotes/ObjectiveC/RN-TransitioningToARC/Introduction/Introduction.html#//apple_ref/doc/uid/TP40011226" target="_blank" rel="external">Transitioning to ARC Release Notes</a></li>
<li><a href="http://www.yifeiyang.net/development-of-the-iphone-simply-1/" target="_blank" rel="external">iOS应用开发：什么是ARC？</a></li>
<li><a href="http://conradstoll.com/blog/2013/1/19/blocks-operations-and-retain-cycles.html" target="_blank" rel="external">Blocks, Operations, and Retain Cycles</a></li>
<li><a href="http://www.cocoachina.com/bbs/read.php?tid=175996" target="_blank" rel="external">iOS7.0 使用ARC</a></li>
<li><a href="http://www.cnbluebox.com/?p=255" target="_blank" rel="external">block使用小结、在arc中使用block、如何防止循环引用</a></li>
<li><a href="http://blog.csdn.net/enuola/article/details/9163051" target="_blank" rel="external">IOS中关于NSTimer使用知多少</a></li>
<li><a href="http://tanqisen.github.io/blog/2013/04/19/gcd-block-cycle-retain/" target="_blank" rel="external">正确使用Block避免Cycle Retain和Crash</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<!-- toc -->
<p>在2011年的WWDC中，苹果提到90%的crash是由于内存管理引起的，ARC（<code>Automatic Reference Counting</code>）就是苹果给出的解决方案。启用ARC后，开发者不需要担心内存管理，编译器会为你处理这一切<em>（注意ARC是编译器特性，而不是iOS运行时特性，更不是其他语言中的垃圾收集器）。</em><br>简单来说，编译器在编译代码时，会自动生成实例的引用计数代码，帮助我们完成之前MRC需要完成的工作，不过据说除此之外，编译器也会执行某些优化。</p>]]>
    
    </summary>
    
      <category term="ARC" scheme="http://luoyibu.com/tags/ARC/"/>
    
      <category term="block" scheme="http://luoyibu.com/tags/block/"/>
    
      <category term="内存泄露" scheme="http://luoyibu.com/tags/%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2/"/>
    
      <category term="内存管理" scheme="http://luoyibu.com/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    
      <category term="iOS" scheme="http://luoyibu.com/categories/iOS/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[SDWebImage源码分析]]></title>
    <link href="http://luoyibu.com/2014/10/12/SDWebImage%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>http://luoyibu.com/2014/10/12/SDWebImage源码分析/</id>
    <published>2014-10-12T10:51:39.000Z</published>
    <updated>2015-12-12T08:40:00.000Z</updated>
    <content type="html"><![CDATA[<!-- toc -->
<p>SDWebImage是一个托管在github上面的开源库。该类库提供了一个UIImageView的category，用来支持异步网络图片，同时具有缓存管理，异步下载等功能。<br>详细介绍与用法请参考 <a href="https://github.com/rs/SDWebImage" target="_blank" rel="external">SDWebImage</a></p>
<a id="more"></a>
<h2 id="SDWebImage_u4F7F_u7528"><a href="#SDWebImage_u4F7F_u7528" class="headerlink" title="SDWebImage使用"></a>SDWebImage使用</h2><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#import <span class="title">&lt;SDWebImage/UIImageView+WebCache.h&gt;</span></span></span><br><span class="line">...</span><br><span class="line">- (<span class="built_in">UITableViewCell</span> *)tableView:(<span class="built_in">UITableView</span> *)tableView cellForRowAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">NSString</span> *MyIdentifier = <span class="string">@"MyIdentifier"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">UITableViewCell</span> *cell = [tableView dequeueReusableCellWithIdentifier:MyIdentifier];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cell == <span class="literal">nil</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cell = [[[<span class="built_in">UITableViewCell</span> alloc] initWithStyle:<span class="built_in">UITableViewCellStyleDefault</span></span><br><span class="line">                                       reuseIdentifier:MyIdentifier] autorelease];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Here we use the new provided setImageWithURL: method to load the web image</span></span><br><span class="line">    [cell<span class="variable">.imageView</span> setImageWithURL:[<span class="built_in">NSURL</span> URLWithString:<span class="string">@"http://www.domain.com/path/to/image.jpg"</span>]</span><br><span class="line">                   placeholderImage:[<span class="built_in">UIImage</span> imageNamed:<span class="string">@"placeholder.png"</span>]];</span><br><span class="line"></span><br><span class="line">    cell<span class="variable">.textLabel</span><span class="variable">.text</span> = <span class="string">@"My Text"</span>;</span><br><span class="line">    <span class="keyword">return</span> cell;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用法很简单，就不介绍了。其他的一些功能（比如单独使用download或者cache机制）参考SDWebImage的Readme。</p>
<h2 id="SDWebImage_u5173_u952E_u7C7B_u4E0E_u5206_u6790"><a href="#SDWebImage_u5173_u952E_u7C7B_u4E0E_u5206_u6790" class="headerlink" title="SDWebImage关键类与分析"></a>SDWebImage关键类与分析</h2><h3 id="Categories"><a href="#Categories" class="headerlink" title="Categories"></a>Categories</h3><p><strong>UIImageView+WebCache UIImageView的category，整个类库的入口。</strong>  </p>
<p><em>还有一些其他的categories，本文只介绍UIImageView。</em></p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)sd_setImageWithURL:(<span class="built_in">NSURL</span> *)url </span><br><span class="line">          placeholderImage:(<span class="built_in">UIImage</span> *)placeholder </span><br><span class="line">                   options:(SDWebImageOptions)options </span><br><span class="line">                  progress:(SDWebImageDownloaderProgressBlock)progressBlock </span><br><span class="line">                 completed:(SDWebImageCompletionBlock)completedBlock </span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">self</span> sd_cancelCurrentImageLoad];</span><br><span class="line">    objc_setAssociatedObject(<span class="keyword">self</span>, &amp;imageURLKey, url, OBJC_ASSO<span class="built_in">CIATION_RETAIN_NONATOMIC</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!(options &amp; SDWebImageDelayPlaceholder)) &#123;</span><br><span class="line">        dispatch_main_async_safe(^&#123;</span><br><span class="line">            <span class="keyword">self</span><span class="variable">.image</span> = placeholder;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (url) &#123;</span><br><span class="line">        __<span class="keyword">weak</span> <span class="built_in">UIImageView</span> *wself = <span class="keyword">self</span>;</span><br><span class="line">        <span class="keyword">id</span> &lt;SDWebImageOperation&gt; operation = </span><br><span class="line">        [SDWebImageManager<span class="variable">.sharedManager</span> downloadImageWithURL:url </span><br><span class="line">                                                      options:options </span><br><span class="line">                                                     progress:progressBlock </span><br><span class="line">                                                    completed:^(<span class="built_in">UIImage</span> *image, <span class="built_in">NSError</span> *error, SDImageCacheType cacheType, <span class="built_in">BOOL</span> finished, <span class="built_in">NSURL</span> *imageURL) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!wself) <span class="keyword">return</span>;</span><br><span class="line">            dispatch_main_sync_safe(^&#123;</span><br><span class="line">                <span class="keyword">if</span> (!wself) <span class="keyword">return</span>;</span><br><span class="line">                <span class="keyword">if</span> (image) &#123;</span><br><span class="line">                    wself<span class="variable">.image</span> = image;</span><br><span class="line">                    [wself setNeedsLayout];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((options &amp; SDWebImageDelayPlaceholder)) &#123;</span><br><span class="line">                        wself<span class="variable">.image</span> = placeholder;</span><br><span class="line">                        [wself setNeedsLayout];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (completedBlock &amp;&amp; finished) &#123;</span><br><span class="line">                    completedBlock(image, error, cacheType, url);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;];</span><br><span class="line">        [<span class="keyword">self</span> sd_setImageLoadOperation:operation forKey:<span class="string">@"UIImageViewImageLoad"</span>];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        dispatch_main_async_safe(^&#123;</span><br><span class="line">            <span class="built_in">NSError</span> *error = [<span class="built_in">NSError</span> errorWithDomain:<span class="string">@"SDWebImageErrorDomain"</span> code:-<span class="number">1</span> userInfo:@&#123;<span class="built_in">NSLocalizedDescriptionKey</span> : <span class="string">@"Trying to load a nil url"</span>&#125;];</span><br><span class="line">            <span class="keyword">if</span> (completedBlock) &#123;</span><br><span class="line">                completedBlock(<span class="literal">nil</span>, error, SDImageCacheTypeNone, url);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每个UIImageView对象都通过objc_setAssociatedObject关联了2个对象：</p>
<ol>
<li>sd_imageURL，通过改属性可以获取image的url.</li>
<li>operationDictionary,该dic中存取了当前imageview对象中正在进行的operation，该operation是由SDWebImageManager通过downloadImageWithURL:options:progress:completed:函数创建的SDWebImageCombinedOperation对象。</li>
</ol>
<p>执行sd_setImageWithURL函数时，会cancel掉operationDictionary中已经存在的operation，并重新创建一个新的SDWebImageCombinedOperation对象来获取image，该operation会被存入operationDictionary中。<br>保证每个UIImageView对象中永远只存在一个operation，该operation负责从缓存中获取image或者是重新下载image。</p>
<p><code>SDWebImageCombinedOperation的cancel操作同时会cacel掉缓存查询的operation以及downloader的operation</code></p>
<p>需要注意的是，在UITableView中，cell是可<code>复用</code>的(关于cell的复用机制，大家可以自行百度).比如有一个tableview有100个row，一屏显示10个row，这样在复用队列中，只存在10个cell对象，也即uiimageview对象也只有10个。这样，在滑动tableview的时候，滑出屏幕的的cell对象，在被复用时，cell上的imageview会cancel掉之前<code>未完成</code>的operation，程序只会下载当前可见cell上面的image。</p>
<h3 id="Utils"><a href="#Utils" class="headerlink" title="Utils"></a>Utils</h3><p><strong>SDWebImageManager 主要逻辑操作，管理图片下载，缓存等</strong> </p>
<p>在上面的category中谈到，会通过SDWebImageManager来创建SDWebImageCombinedOperation对象，我们看看详细的代码：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">id</span> &lt;SDWebImageOperation&gt;)downloadImageWithURL:(<span class="built_in">NSURL</span> *)url</span><br><span class="line">                                         options:(SDWebImageOptions)options</span><br><span class="line">                                        progress:(SDWebImageDownloaderProgressBlock)progressBlock</span><br><span class="line">                                       completed:(SDWebImageCompletionWithFinishedBlock)completedBlock </span><br><span class="line">&#123;                                           </span><br><span class="line">    __block SDWebImageCombinedOperation *operation = [SDWebImageCombinedOperation new];</span><br><span class="line">    __<span class="keyword">weak</span> SDWebImageCombinedOperation *weakOperation = operation;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">BOOL</span> isFailedUrl = <span class="literal">NO</span>;</span><br><span class="line">    <span class="keyword">@synchronized</span> (<span class="keyword">self</span><span class="variable">.failedURLs</span>) &#123;</span><br><span class="line">        isFailedUrl = [<span class="keyword">self</span><span class="variable">.failedURLs</span> containsObject:url];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!url || (!(options &amp; SDWebImageRetryFailed) &amp;&amp; isFailedUrl)) &#123;</span><br><span class="line">        dispatch_main_sync_safe(^&#123;</span><br><span class="line">            <span class="built_in">NSError</span> *error = [<span class="built_in">NSError</span> errorWithDomain:<span class="built_in">NSURLErrorDomain</span> code:<span class="built_in">NSURLErrorFileDoesNotExist</span> userInfo:<span class="literal">nil</span>];</span><br><span class="line">            completedBlock(<span class="literal">nil</span>, error, SDImageCacheTypeNone, <span class="literal">YES</span>, url);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> operation;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">@synchronized</span> (<span class="keyword">self</span><span class="variable">.runningOperations</span>) &#123;</span><br><span class="line">        [<span class="keyword">self</span><span class="variable">.runningOperations</span> addObject:operation];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    operation<span class="variable">.cacheOperation</span> = [<span class="keyword">self</span><span class="variable">.imageCache</span> queryDiskCacheForKey:key done:^(<span class="built_in">UIImage</span> *image, SDImageCacheType cacheType) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((!image || options &amp; SDWebImageRefreshCached) &amp;&amp; (![<span class="keyword">self</span><span class="variable">.delegate</span> respondsToSelector:<span class="keyword">@selector</span>(imageManager:shouldDownloadImageForURL:)] || [<span class="keyword">self</span><span class="variable">.delegate</span> imageManager:<span class="keyword">self</span> shouldDownloadImageForURL:url])) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">id</span> &lt;SDWebImageOperation&gt; subOperation = [<span class="keyword">self</span><span class="variable">.imageDownloader</span> downloadImageWithURL:url options:downloaderOptions progress:progressBlock completed:^(<span class="built_in">UIImage</span> *downloadedImage, <span class="built_in">NSData</span> *data, <span class="built_in">NSError</span> *error, <span class="built_in">BOOL</span> finished) &#123;</span><br><span class="line">				...</span><br><span class="line">				<span class="comment">//进行一些处理，并缓存图片</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (finished) &#123;</span><br><span class="line">                    <span class="keyword">@synchronized</span> (<span class="keyword">self</span><span class="variable">.runningOperations</span>) &#123;</span><br><span class="line">                        [<span class="keyword">self</span><span class="variable">.runningOperations</span> removeObject:operation];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;];</span><br><span class="line">            operation<span class="variable">.cancelBlock</span> = ^&#123;</span><br><span class="line">                [subOperation cancel];</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">@synchronized</span> (<span class="keyword">self</span><span class="variable">.runningOperations</span>) &#123;</span><br><span class="line">                    [<span class="keyword">self</span><span class="variable">.runningOperations</span> removeObject:weakOperation];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (image) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">@synchronized</span> (<span class="keyword">self</span><span class="variable">.runningOperations</span>) &#123;</span><br><span class="line">                [<span class="keyword">self</span><span class="variable">.runningOperations</span> removeObject:operation];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> operation;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em>代码有删减，细节请查看源码</em></p>
<p>主要操作：</p>
<ol>
<li>满足条件 <code>(!url || (!(options &amp; SDWebImageRetryFailed) &amp;&amp; isFailedUrl))</code> 则直接return.<br><em>在manager中管理了一个failedURLs的array，里面下载失败的url会被存储下来. 同时，可以通过SDWebImageRetryFailed来强制继续重试下载</em></li>
<li>查找缓存，若缓存中没有image则通过SDWebImageDownloader来进行下载，下载完成后通过SDImageCache进行缓存，会同时缓存到memCache和diskCache中</li>
</ol>
<p><strong>SDWebImageDecoder 磁盘图片读出来后进行decoder操作</strong></p>
<p>虽然iOS现在支持UIImage直接序列化到文件，但是据说对内存资源消耗较大（待考证，先留在此处）。所以推荐将UIImage转化为NSData再序列化到本次，那么问题来了：</p>
<blockquote>
<p>由于UIImage的imageWithData函数是每次画图的时候才将Data解压成ARGB的图像，<br>所以在每次画图的时候，会有一个解压操作，这样效率很低，但是只有瞬时的内存需求。<br>为了提高效率通过SDWebImageDecoder将包装在Data下的资源解压，然后画在另外一张图片上，这样这张新图片就不再需要重复解压了。这种做法是典型的空间换时间的做法。</p>
</blockquote>
<p>为啥要做decoder: 参考<a href="http://www.cocoanetics.com/2011/10/avoiding-image-decompression-sickness/" target="_blank" rel="external">avoiding-image-decompression-sickness</a></p>
<h3 id="Cache"><a href="#Cache" class="headerlink" title="Cache"></a>Cache</h3><p><strong>SDImageCache 缓存管理，包括内存缓存和磁盘缓存，缓存以url作为key</strong> </p>
<p>缓存管理在manager中主要有2个操作，一个是下载前查询缓存中是否存在image，一个是下载后缓存image。</p>
<h4 id="u67E5_u8BE2_u7F13_u5B58"><a href="#u67E5_u8BE2_u7F13_u5B58" class="headerlink" title="查询缓存"></a>查询缓存</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">NSOperation</span> *)queryDiskCacheForKey:(<span class="built_in">NSString</span> *)key done:(SDWebImageQueryCompletedBlock)doneBlock </span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// First check the in-memory cache...</span></span><br><span class="line">    <span class="built_in">UIImage</span> *image = [<span class="keyword">self</span> imageFromMemoryCacheForKey:key];</span><br><span class="line">    <span class="keyword">if</span> (image) &#123;</span><br><span class="line">        doneBlock(image, SDImageCacheTypeMemory);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSOperation</span> *operation = [<span class="built_in">NSOperation</span> new];</span><br><span class="line">    <span class="built_in">dispatch_async</span>(<span class="keyword">self</span><span class="variable">.ioQueue</span>, ^&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">            <span class="built_in">UIImage</span> *diskImage = [<span class="keyword">self</span> diskImageForKey:key];</span><br><span class="line">            <span class="keyword">if</span> (diskImage) &#123;</span><br><span class="line">                <span class="built_in">CGFloat</span> cost = diskImage<span class="variable">.size</span><span class="variable">.height</span> * diskImage<span class="variable">.size</span><span class="variable">.width</span> * diskImage<span class="variable">.scale</span>;</span><br><span class="line">                [<span class="keyword">self</span><span class="variable">.memCache</span> setObject:diskImage forKey:key cost:cost];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                doneBlock(diskImage, SDImageCacheTypeDisk);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> operation;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先查询内存中的缓存，然后查询磁盘中的缓存，若磁盘中存在缓存，同时需要将图片放入内存缓存中去。</p>
<h4 id="u5B58_u50A8_u7F13_u5B58"><a href="#u5B58_u50A8_u7F13_u5B58" class="headerlink" title="存储缓存"></a>存储缓存</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)storeImage:(<span class="built_in">UIImage</span> *)image recalculateFromImage:(<span class="built_in">BOOL</span>)recalculate imageData:(<span class="built_in">NSData</span> *)imageData forKey:(<span class="built_in">NSString</span> *)key toDisk:(<span class="built_in">BOOL</span>)toDisk </span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    [<span class="keyword">self</span><span class="variable">.memCache</span> setObject:image forKey:key cost:image<span class="variable">.size</span><span class="variable">.height</span> * image<span class="variable">.size</span><span class="variable">.width</span> * image<span class="variable">.scale</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (toDisk) &#123;</span><br><span class="line">        <span class="built_in">dispatch_async</span>(<span class="keyword">self</span><span class="variable">.ioQueue</span>, ^&#123;</span><br><span class="line">            <span class="built_in">NSData</span> *data = imageData;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (image &amp;&amp; (recalculate || !data)) &#123;</span><br><span class="line"><span class="preprocessor">#if TARGET_OS_IPHONE</span></span><br><span class="line">                <span class="comment">// We need to determine if the image is a PNG or a JPEG</span></span><br><span class="line">                <span class="comment">// PNGs are easier to detect because they have a unique signature (http://www.w3.org/TR/PNG-Structure.html)</span></span><br><span class="line">                <span class="comment">// The first eight bytes of a PNG file always contain the following (decimal) values:</span></span><br><span class="line">                <span class="comment">// 137 80 78 71 13 10 26 10</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// We assume the image is PNG, in case the imageData is nil (i.e. if trying to save a UIImage directly),</span></span><br><span class="line">                <span class="comment">// we will consider it PNG to avoid loosing the transparency</span></span><br><span class="line">                <span class="built_in">BOOL</span> imageIsPng = <span class="literal">YES</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// But if we have an image data, we will look at the preffix</span></span><br><span class="line">                <span class="keyword">if</span> ([imageData length] &gt;= [kPNGSignatureData length]) &#123;</span><br><span class="line">                    imageIsPng = ImageDataHasPNGPreffix(imageData);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (imageIsPng) &#123;</span><br><span class="line">                    data = <span class="built_in">UIImagePNGRepresentation</span>(image);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    data = <span class="built_in">UIImageJPEGRepresentation</span>(image, (<span class="built_in">CGFloat</span>)<span class="number">1.0</span>);</span><br><span class="line">                &#125;</span><br><span class="line"><span class="preprocessor">#else</span></span><br><span class="line">                data = [<span class="built_in">NSBitmapImageRep</span> representationOfImageRepsInArray:image<span class="variable">.representations</span> usingType: <span class="built_in">NSJPEGFileType</span> properties:<span class="literal">nil</span>];</span><br><span class="line"><span class="preprocessor">#endif</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (data) &#123;</span><br><span class="line">                <span class="keyword">if</span> (![_fileManager fileExistsAtPath:_diskCachePath]) &#123;</span><br><span class="line">                    [_fileManager createDirectoryAtPath:_diskCachePath withIntermediateDirectories:<span class="literal">YES</span> attributes:<span class="literal">nil</span> error:<span class="literal">NULL</span>];</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                [_fileManager createFileAtPath:[<span class="keyword">self</span> defaultCachePathForKey:key] contents:data attributes:<span class="literal">nil</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>图片下载后会通过该函数缓存图片，图片首先放入内存缓存中，然后通过ioQueue放入磁盘缓存</p>
<h4 id="u5173_u4E8E_u78C1_u76D8_u7F13_u5B58"><a href="#u5173_u4E8E_u78C1_u76D8_u7F13_u5B58" class="headerlink" title="关于磁盘缓存"></a>关于磁盘缓存</h4><p>由于磁盘缓存涉及多线程读写操作，SDWebImage采用了串行队列来保证线程安全<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// <span class="operator"><span class="keyword">Create</span> IO <span class="built_in">serial</span> queue</span><br><span class="line">_ioQueue = dispatch_queue_create(<span class="string">"com.hackemist.SDWebImageCache"</span>, DISPATCH_QUEUE_SERIAL);</span></span><br></pre></td></tr></table></figure></p>
<h3 id="Downloader"><a href="#Downloader" class="headerlink" title="Downloader"></a>Downloader</h3><p>SDWebImageDownloader 管理图片下载<br>SDWebImageDownloaderOperation 实际下载请求,继承NSOperation。</p>
<p><em>其他一些参考</em></p>
<p><a href="http://blog.csdn.net/uxyheaven/article/details/7909373" target="_blank" rel="external">SDWebImage 笔记</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<!-- toc -->
<p>SDWebImage是一个托管在github上面的开源库。该类库提供了一个UIImageView的category，用来支持异步网络图片，同时具有缓存管理，异步下载等功能。<br>详细介绍与用法请参考 <a href="https://github.com/rs/SDWebImage">SDWebImage</a></p>]]>
    
    </summary>
    
      <category term="SDWebImage" scheme="http://luoyibu.com/tags/SDWebImage/"/>
    
      <category term="iOS" scheme="http://luoyibu.com/categories/iOS/"/>
    
  </entry>
  
</feed>
